\section{100 prisoners}

\begin{multicols}{2}
Trump da un'ultima possibilità di freedom a 100 scenziati, trump da un numero da 1 a 100 ad ogni scenziato. 
 \columnbreak 
\begin{center}
\fbox{\begin{minipage}[c][7.0cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_094931.png\end{minipage}}
\end{center}
\end{multicols}

C'è una stanza con 100 cassetti, ognuno contiene un numero ma non si conosce, ogni scenziato entra e può aprirne 50. Gli scenziati vincono se tutti trovano il loro numero. si comunicano all'inizio ma dopo non possono.

\begin{itemize}
  \item Trivial Solution: nessuno si mette d'accordo e ognuno apre a caso. $\frac{1}{2}$ oppure il 50\% di successo per il singolo ma $\frac{1}{2^{100}}$ che tutti vincono, coglioniiiii.
\end{itemize}

Si usa una strategia adaptive, per aprire i drawer.

\begin{enumerate}
  \item Scenziato numero $i$ apre il drawer $i$ con numero $d_i$, se $d_i == i$ allora vince.
  \item Se no apre il drawer $d_i$ e continua cosi.
\end{enumerate}

\begin{center}
\fbox{\begin{minipage}[c][5.6cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_103613.png\end{minipage}}
\end{center}

Ovviamente è un ciclo, quando lo percorriamo tutto si arriva alla soluzione, perche l'ultimo è il nostro, quindi per vincere dobbiamo prendere un ciclo minore di 50, quindi quale è questa probabilità? 

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_111744.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_112458.png\end{minipage}}
\end{center}

Si ma non esistono cicli in questi drawer, c'è solo un ciclo, cambia solo da che nodo ci entri. 

Quindi l'equazione diventa tutte le permutazioni possibili, l'ordine che hanno visto che lo sappiamo gia, e poi gli elementi che mancano: 
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_113544.png\end{minipage}}
\end{center}

quindi come si calcola? si fa:
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_113709.png\end{minipage}}
\end{center}

Vediamo che non è brutto adesso, rispetto alla soluzione trivial, abbiamo una probabilità piu grande yeeee.

\section{Super clever algoritm}
\subsection{Duplicate Eleemnts in an array}
\label{dupliactearray}
Siamo un un array $A[0,...,n]$ di n+1 numeri in $\{0,...,n-1\}$, dobbiamo trovare almeno un elemento duplicato.

Si usa una bit map per vedere se abbiamo gia visto quel valore:
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_114419.png\end{minipage}}
\end{center}

Complessità, $\Theta (n)$ tempo, ma anche $\Theta (n)$ space, quindi dobbiamo sistemarlo. Sembra impossibile perche gia usiamo solo 1 bit per risolvere questo problema.


\subsubsection{log n passes}
Si fanno $\Theta (\log n)$ passes su A, ovvero si ricostruisce l'array e (bitmap) bit per bit.

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_115155.png\end{minipage}}
\end{center}

si guardano prima le cifre piu alte dei numeri, poi si guardano quelle intermedie and so on, cosi si fa lungo $\log n $ e, e ci settiamo solamente chi troviamo 

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_115344.png\end{minipage}}
\end{center}

Greve in questa mnaiera ci troviamo i duplicati direttamente alla fine. Per ogni cifra si conta chi ne ha di piu, se troviamo piu 1 o piu zeri ce lo segniamo e si restringe via via il campo. Notiamo che è molto bellino ma solo se faccimao niente random access, se no siamo piu lenti di prima insomma.

\subsubsection{Destroy A}
Ma se potessimo fare random access possiamo andare piu veloce? possiamo ma si distrugge A, quindi dobbiamo fare una copia in caso. Questa soluzione deriva dai 100 prisoners.

Si spostano i numeri nella loro posizione corretta, e quindi basta controllare la loro posizione una volta che si trovano (random access), e via.

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_120010.png\end{minipage}}
\end{center}

\subsection{Floyds cycle finding}
\label{floyds}
Trovare l'inizio di un ciclo in una lista in $\Theta(1)$ extra space, la lista è read only

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_151924.png\end{minipage}}
\end{center}

Si usano 2 puntatori, $S$ Slow si muove solo 1 step, e $F$ Fast che si muove 2 step by 2.

\begin{enumerate}
  \item Prima si trovano nel ciclo, cosi da certificare il fatto che il ciclo esiste (lo sappiamo per cui seccederà). 
  \item Poi riportiamo F all'inizio e lo settiamo con speed 1, mentre intanto S continua.
\end{enumerate}

MAGIA: Quando si ritroveranno, si ritroveranno all'inizio del ciclo. Questo perche $S$ fa $m$ steps, mentre $F$ fa $2m$ steps, si chiama $a$ la lunghezza del prefisso prima dell'inzio del ciclo, mentre $b$ quanto sono dentro al loop, per cui:

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_152526.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_152927.png\end{minipage}}
\end{center}

$$
m = a + b
$$

$$
2m = a+ b + k * \text{length of the loop (=b)} 
$$
$$
a = k * l - b
$$

\subsection{Majority Element}
Dato un array $A[1,n]$ trovare se c'è, l'elemento che occorre almeno $\frac{n}{2}+1$ volte, quindi la maggioranza.

Soluzioni:

\begin{itemize}
  \item Sort $\Theta(n \log n) $ time $\Theta(n)$ space
  \item hashmap $\Theta(n )*$ time $\Theta(n)$ space (l'hashmap è probabilistica dipende)
\end{itemize}

possiamo fare meglio in spazio? vogliamo tempo lineare $\Theta(n)$ e spazio costante$\Theta(1)$, 

\subsubsection{Boyer Moore Algorithm}
Abbiamo un array.

Si prende un candidato $c$ e $a$ un counter, si processa da sinistra a destra, e ad ogni itereazione abbiamo $A[i]$, e se $A[i]$ == $c$ si aumenta il counter di 1, se no :

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_154532.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_154632.png\end{minipage}}
\end{center}

\subsubsection{Support Insertion/Deletion}
Abbiamo un array, si inserisce nella sequenza, oppure si fa la deletion, e dopo ogni singola operazione ci chiediamo quale è il majority. E vogliamo $\Theta(\log n)$ time e space.

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_155657.png\end{minipage}}
\end{center}

Si fa la binary rappresentation per questa robetta, e si contano il numero di 0 e di 1.

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_160017.png\end{minipage}}
\end{center}

bellissimi, adesso se facciamo un sacco di operazioni di delete e una insert, come si fa? basta che si fa la update dei nostri calcoli, una delete 

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_160353.png\end{minipage}}
\end{center}

\clearpage 

\subsection{Misra-Gries Heavy Hitter} 
Dato un array$A[1,n]$, trovare l'elemento $T-1$ che occore almeno $\frac{n}{T}+1$ volte, stiamo generalizzando il problmea majority, con $T=2$ è quello. 

Si tiene un set $K$ di $T$ candidati e counters, 

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251110\_161014.png\end{minipage}}
\end{center}

Abbiamo $\Theta (T \cdot n)$ Time, godo

\section{Alice and bob }
\label{aliceandbob}
Alice seleziona prima e Bob seleziona dopo, 2n numeri, Regola di Scelta: Un giocatore può prendere un numero solo da una delle due estremità della fila rimasta. Obiettivo: Ogni giocatore vuole massimizzare la somma totale dei numeri che ha raccolto. Alice vince se la sua somma finale (SA) è maggiore o uguale a quella di Bob (SB).

L'intuizione chiave: Scegliendo un numero da una posizione dispari (la 1°), Alice costringe Bob a scegliere tra due numeri che sono entrambi in posizioni pari. Qualunque numero Bob scelga, "scoprirà" un nuovo numero in posizione dispari per Alice.

Alice può continuare così per tutto il gioco, prendendo sempre un numero dal set "Dispari", e Bob sarà sempre costretto a prendere un numero dal set "Pari".

grazie gemini! insomma lei prima calcola quale è la somma vincente, se quella nei numeri pari o nei numeri dispari (posizioni negli array) e cosi cosi gasse.

\clearpage

\section{Fenwick Tree binary indexed tree, BIT}
\label{newfenwik}
\subsection{Dynamic Prefix Sums}
Dato un array $A[1,n]$ vorremmo supportare le seguenti operazioni: IN LOGARITMIC TIME.

\begin{itemize}
    \item $\text{Sum}(i) = \sum_{k=1}^i A[k] $
    \item $\text{Add}(i,v) = A[i] += v $
\end{itemize}

$RangeSum(i,j) =  Sum(j) - Sum(i-1)$

\underline{Solution}
Prendiamo una versione rilassata del problema, la add rimane uguale, ma la sum si fa solo per le posizioni $i$ che sono una potenza di due:

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_112943.png\end{minipage}}
\end{center}
\columnbreak
Qui creaiamo un albero per la prefix sum, solamente per le potenze di due, cosi se ci chiedono la sum la sappiamo, e se chiedono la add, possiamo farlo, tipo add 2 in posizione 3, basta che aggiungiamo nel nodo 4 e 8 dell'albero 2, e si fa un tempo logaritmico. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_113058.png\end{minipage}}
\end{center}
\columnbreak
Adesso visto che facciamo questa cosa solo per le potenze di due, vediamo come tutti i nodi hanno solamente un bit settato a 1. 
\end{multicols}


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_113838.png\end{minipage}}
\end{center}
\columnbreak
Qui si continua con 2 bit a 1, e vediamo come i figli vengono messi seguendo i bit del padre, il nodo 3 ha 2 bit dopo il nodo 2, uguale il 5 e il 6 hanno 2 bit dove il padre ne ha solo 1, mi so spiegato di merda ma si vede via. Praticamente il prefisso è del padre e il suffisso è del figlio, cosi si capisce meglio.
\end{multicols}


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_120123.png\end{minipage}}
\end{center}
\columnbreak
Adesso cerchiamo di capire la regola, manca solo il nodo 7, dove va messo? si mette nel livello che ha quanti 1 ci sono nella sua rappresentazione binaria, 7 = \texttt{0111} quindi la terzo livello, e il suo padre chi sarà? 6 ovviamente, il suo prefisso è \texttt{011} e quindi suo figlio sarà per forza \texttt{0111}
\end{multicols}

Quindi non serve una structure per il tree, non ci serve nemmeno l'array inziale, si tiene solo il nostro FenwickTree dentro l'array, tanto con sum si ricostruisce tutto, quindi 0 extra space.

COme si fa la sum? si parte dalla posizione chiesta ? quindi sum(3) si parte dal nodo tre dell'albero e si somma con i suoi genitori, quindi ci serve l'operazione di parent() e basta per fare la sum, quindi gasse.


\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_144043.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_144527.png\end{minipage}}
\end{center}

La cosa figa di qeusta struttura è che ha 0 extra space e il modo per calcolare il parent super easy. Quale è la sua \textbf{altezza}? $\log n$, questo perche sono tutte le potenze di 2. 
godo

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_145327.png\end{minipage}}
\end{center}

Per fare la add è la solita storia, dobbiamo andare a destra e in alto, quindi gasse dobbiamo trovare il nodo a destra, ed è come il parent ma invece che togliere il trailing one (appunti vecchi gasse) si aggiunge.

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_150246.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251114\_150327.png\end{minipage}}
\end{center}

\subsection{Counting Inversion}
\label{ci}
Dato $A[1n]$ di numeri poisitivi $\le n$ contare il numero di inversions in $A$.

Una inversion è $i < j$ such that $A[i]>A[j]$. 
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_152154.png\end{minipage}}
\end{center}
Questo conta quanto non è sortato l'array, ovviamente il bound è quando l'array è sortato in revers order.  

Soluzione trivial, fare insertion sort o contare gli steps, ma è $\Theta(n^2)$ time. C'è anche una soluzione mergesort based n logge enne ma non ci freca (basta contare le singole inversioni che fa il mergesort).

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_153936.png\end{minipage}}
\end{center}
\columnbreak
FT based: si costruisce il FenwickTree dove in ogni posizione $F[j]$ ha la frequenza dell'elemnto di $A[i] = j$, si fa uno scan da sinistra a destra di A, e si da l'update di questa bellissima cosa. Mentre popoliamo il FT è facilissimo vedere quante inversioni abbiamo all'interno di $A$, basta fare una rangesum dalla posizione dopo il nostro $j$ fino alla fine del FT, quindi easy.  come si vede dall'immagine si arriva a 1 e basta fare la somma di tutto l'array dopo e gasse. Quindi $\Theta (n \log n)$ time. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_154448.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_154532.png\end{minipage}}
\end{center}
\columnbreak
In caso il max value fosse troppo grosso, chiaramente non dobbiamo fare un FT enorme, ma basta remappare. Si sortano e diamo il rank, e si sostuiscono i valori con il loro rank, tnato ci importa delle inversion non dei valori effettivi, godo.
\end{multicols}

\subsection{Nested Segment}
\label{ns}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_155008.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_161220.png\end{minipage}}
\end{center}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_162556.png\end{minipage}}
\end{center}
\columnbreak
Facciamo un bel remap con l'inizio e la fine dei segmenti, successivamente si fa uno scan e si mette 1 nelle posizioni dove i segmenti iniziano (sinistra ovviamente diobe).

Quindi ora si fa la range sum dentro il range di un segmento, e infatti gasse si trova la risposta al nostro problema, ma comunque dobbiamo escludere delle cose, 7 e 9 sono di troppo, ma come si fa?  
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_162857.png\end{minipage}}
\end{center}
\columnbreak
Si inizia dall'ultimo segmento, che sicuramente va benissimo e si fa la sua range sum, e poi che si fa? siamo una struttura dinamica, allora si elimina il suo inizio, gasse cosi si toglie per gli altri, cosi si tratta sempre il segmento corrente come l'ultimo gasseeeeeeeeeeeeeeeeeeeeee.
\end{multicols}

\subsection{Update the Array}
\label{ua}
Dato un array di soli 0 vogliamo supportare 2 operazioni:

\begin{itemize}
  \item Access(i) = A[i]
  \item Update(i,j,v) = $\forall k \in [i,j]$ allora $A[k] += v$ 
\end{itemize}


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_172803.png\end{minipage}}
\end{center}
\columnbreak
Si tiene V ovvero un FT, dove la posizione $i$ è la prefix sum fino ad $i$ di $A$, ovvero $\forall i A[i] = \sum^i_{k=1 } V[k]$, praticamente la prefix sum di V è l'array A. Cosi se facciamo +1 in una posizione di V, questo si propaga direttamente in ogni posizione a destra, in questa maniera se si fa l'update, basta mettere $+v$ in posizione $i$ e $-v$ in posizione $j+1$, cosi da cancellare quella propagazione
\end{multicols}


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_173156.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251115\_173247.png\end{minipage}}
\end{center}
\columnbreak
Ogni update si trasla con 2 add sul FT per funzionare, mentre un access è semplicemente una somma 
\end{multicols}

Una cosa che non avevo capito, il FT non è una scatola nera, fa solamente parent e moveright, serve solo a questo, in questo caso la add non propaga come abbiamo visto inizialmente per fare la dynamic prefix sum madonna bestia laida, quindi semplicemente si fa la add sul singolo nodo e gasse cosi quando facciamo la sum effettivamente è tutto aggiornato, godo. E' vero che in questo caso V (l'FT) è la prefix sum di A in ogni singolo $i$, godo, e per questo si fanno due add per le update. 

\clearpage

\subsection{Dynamic Prefix Syms with range update}
Dato A[1,n] 

\begin{itemize}
  \item rangeupdate(i,j,v)
  \item sum(i)
  \item access(i) = sum(i) - sum(i-1)
\end{itemize}

NOtare, la sum(i) non è come la $sum_v(i)$ del problema precedente, vogliamo proprio la sum di $i$ in $a$ quindi gasse.

\begin{multicols}{2}
Il sunto è che se gestiamo la rangeupdate come facciamo di solito, non abbiamo dei risultati corretti, in questo caso il prof dice moltiplichiamo per i la sum del FT, ma è corretto solo se si inizia sempre dall'inizio con la rangeupdate diobestia. 
\columnbreak
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_104717.png\end{minipage}}
\end{center}
\end{multicols}

\begin{multicols}{2}
Dobbiamo usare 2 FT, il primo si usa come prima, stessa strategia, ma dobbiamo avere un secondo FT con le correzioni del primo. 
\columnbreak
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_110140.png\end{minipage}}
\end{center}
\end{multicols}

\clearpage

\section{Segment Tree}
\label{st}
Stesso problema del FT, sempre la add ma un problema diverso per la range sum è piu generale, per esempio range min  

\underline{Ricordarsi:} occupa il doppio dello spazio del FT, visto che FT è implicito
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_114441.png\end{minipage}}
\end{center}


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_115848.png\end{minipage}}
\end{center}
\columnbreak
Si fa un binary tree sopra i valori, combinando le coppie delle posizioni, nei padri si mettono le sum dei figli, visot che la nostra operazione è quella (?), 
\end{multicols}

Praticamente il funzionamento è: ci teniamo nei nodi la risposta ai nodi sotto di noi.
\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_120745.png\end{minipage}}
\end{center}
\columnbreak
Ora ci serve una update e un modo per rispondere al problema. E la update deve fare $\Theta(\log n)$ nodi.
\end{multicols}

Per la range sum come si fa? in questo caso abbiamo query range 2 e 6, e si fa la compare con i node range, e abbiamo 3 casi,

\begin{multicols}{2}
\begin{enumerate}
  \item Total Overlap:  quando il query range contiene totalmente il node range, quindi la risposta del nodo è richiesta per rispondere alla domanda richiesta. Si prende direttamente il valore e lo usiamo per la risposta
  \item Partial Overlap: la risposta che cerchiamo è dentro in un qualche sub tree dentro il nostro nodo. Il nodo non ha la risposta ma solamente un suo descendent ha la risposta, quindi si deve continuare la ricorsione, in quale side? si va in tutte e due.

  \item No overlap: nessun nodo ha questa risposta, per cui non si prende. Si lascia stare nessun overlap ci stoppiamo.
\end{enumerate}
\columnbreak
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_122905.png\end{minipage}}
\end{center}
\end{multicols}

\clearpage 

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_124650.png\end{minipage}} 
\end{center} 
\columnbreak
E' un'algoritmo recursive che parte dal nodo, e ha tutti e 3 i casi, 
Si vede bene che si arriva a certi nodi dove abbiamo del partial overlap, e semplicemente seguiamo quello che abbiamo gia fatto
\end{multicols}

Quindi è linear o logaritmic? è linear nel nostro esempio, per cui come si fa? con questi partial overlaps diventa linear a forsa di andare a sinistra e destra. Non ho capito però i discorsi del prof, e il running time è log n insomma, perche si usa toccano almeno $4 \log n$ nodi.

Ora un'altro problema che questa struttura può risolvere: 
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_130309.png\end{minipage}}
\end{center}

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_130309.png\end{minipage}}
\end{center}

\subsection{BMQ with occurrency}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_165416-1.png\end{minipage}}
\end{center}


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_165854.png\end{minipage}}
\end{center}

\columnbreak
Allora si crea l'abero per fare questo bellissimo algoritmo, se comunque dovessimo fare una update viene lo stesso, vabbe fa cagare sto problema perche lo ha spiegatoooooooooooooooooo
\end{multicols}

\subsection{problema piu greve}
Array con NON NEGATIVE integer, vogliamo:

\begin{itemize}
  \item add(i,v)
  \item Rangesum(i,j)
  \item search(s) : report the position $i$ of the shortest prefix of $A$ such that $\sum_{j=1}^{i} A[k] \ge s$
\end{itemize}

\begin{multicols}{2}

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_171727.png\end{minipage}}
\end{center}

\columnbreak

Trivial si cerca con una binary search ma viene una merdina, quindi che si fa, dobbiamo fare la ricerca di 23, si inizia dalla root, si dice ma 8 è troppo piccolo per arrivare a 23, quindi si va direttamente a destra perche si cerca 23-8, allora si cerca per 15 visto che togliamo il figlio di sinistra, allora 19 è maggiore o uguale  a 15, allora si cerca li dentro, 6 è piu piccolo di 15, allora si cerca 15-6 e infatti 13 è piu grande allora gasse.
\end{multicols}

Quale è il running time? va in $\Theta \log n$ 

\subsection{problema piu greveeeeee}
Dato A di interi:

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_173610.png\end{minipage}}
\end{center}

Notare che abbiamo $\Theta \log n$ mentre abbiamo $\Theta n \log n$ spazio per colpa dell'hashmap. 

\subsection{problema piu greveeeeeeeeeeeeeeee}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_174957.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_175050.png\end{minipage}}
\end{center}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_175458.png\end{minipage}}
\end{center}
\columnbreak
Si tiene un bst in ogni nodo, cosi da cercare il successor nel range in $\log n$ time, Si computa il successore per tutti i total overlapping node, e si uniscono prendendo il minimo, e query time $\Theta(\log^n n)$, mentre space usage $\Theta( n \log n)$, query time can be improved, 

\end{multicols}

\subsection{Triplets}
Usa segment tree o FT, per risolvere un problema, dato $A[0,n-1]$ di integer, e vogliamo contare nell'array il numero di triplìette (number of ways of 3 values), 

$$
i,j,k \,\,\,\, (0 \le j < j < k < n) 
$$

such that 

$$
A[i] < A[j] < A[k]
$$


Esempio: 
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_180054.png\end{minipage}}
\end{center}

\begin{multicols}{2}
\begin{center}
\end{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251117\_180518.png\end{minipage}}

\columnbreak

Si processa l'array da sinistra a destra, e si contano il numero di occorrenze dei valori piu piccoli nel prefisso del FT, per 5 tipo c'è solamente un valore prima di 5, ovvero 3, mentre se la query fosse stata 7 allora sarebbe stato 4 la risposta, cosi si fa il $k$ per ogni elemento godo, poi si fa questa cosa anche da destra a sinistra e si riconta. 
\end{multicols}

\subsection{Range update with Lazy Propagation}
\label{rulp}
Dato A[1,n]:  
\begin{itemize}
  \item Rangeupdate(i,j,v)
  \item Sum(i)
\end{itemize}

Ricordarsi che se non è sum ma è access possiamo usare FT con la soluzione gia vista, e comunque abbiamo visto anche per sum, ma è solo specifica per quello, mentre con ST possiamo fare molte piu operazioni.

Soluzione: Si tengono due ST, che tiene l'operazione che vogliamo, quindi in questo caso la somma, ma se ne tiene un'altro il \textbf{Lazy Tree} dove ci mettimao gli update che ancora dobbiamo propagare, ovvero che facciamo, ma ancora non ci sono nell'altro ST. 

\begin{multicols}{2}
 \begin{center}
   \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_110350.png\end{minipage}}
 \end{center}
\columnbreak
Facciamo la RangeUpdate(0,4,20), ogni volta che abbiamo una partial overlap si fa l'update dentro ST, si parte dalla root, abbiamo partial overlap, (il range è 0,4), quindi si aggiunge +100 alla root, questo perche abbiamo da fare l'update di 5 nodi, 20 * 5 = 100.
\end{multicols}

ricordiamo le regole:

\begin{itemize}
  \item partial: si fa l'update su ST 
  \item Total: si fa solamente l'update sul Lazy, solo se non è una leaf. 
\end{itemize}

\begin{multicols}{2}
 \begin{center}
   \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_111127.png\end{minipage}}
 \end{center}
\columnbreak
Ora dobbiamo scegliere tra destra e sinistra, a sinistra abbiamo total overlap, e destra abbiamo partial overlap, quindi sul nodo di sinistra si fa il +20 nel lazy (in realtà sarebbe 80) ma è implicito perche tanto va fatto anche nei nodi sotto, quindi ci ricordiamo solo il 20 nel lazy (secondo me uno fa confusione proofoofofofoofofo).
Nel nodo di destra come detto abbiamo PO, quindi si fa +20, e questo perchè la porzione di intervallo è solamente di un nodo, quindi solamente +20. 
\end{multicols}

\begin{multicols}{2}
 \begin{center}
   \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_122851-1.png\end{minipage}}
 \end{center}
\columnbreak
Adesso sotto 21, abbiamo che 19 ha partial overlap, quindi si fa +20.
Sotto 19 abbiamo 6 e 13, e 6 è un total overlap ma è una leaf quindi si scrive direttamente. A destra niente e anche a destra di quello sopra niente 
\end{multicols}

Quale è il running time? come con sum, si toccano $\log n$ nodi, ma per ogni nodo quanto tempo? partial overlap è costant time, questo perche si toccano tutti i suoi nodi che servono, no overlap costant time, mentre total overlap? si mettono nel lazy tree quindi sempre costant time. Quidi $\Theta (\log n)$ time.

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_123658.png\end{minipage}}
\end{center}
\columnbreak
BELLISSIMOOOOOOOOOOO

Ora come si fa la Sum? Sum(3) = RangeSum(0,3), si guarda per ogni nodo se nel lazy tree c'è un \textbf{pending update}, se c'è allora si aggiorna il nodo corrente che ci da la risposta, e si aggiunge nel lazy tree il pending update dei nodi sotto, cosi se mai dovessero servirci si facciamo l'update. Ora abbiamo la risposta alla nostra sum e via. 
\end{multicols}

Quindi per un range update non si paga subito il costo ma si paga solo quando serve, cosi abbiamo tempo logaritmic. Anche la Sum va in $\Theta (\log n)$.

\clearpage

Altri appunti per cercare di capire meglio:

\begin{center}
\fbox{\begin{minipage}[c][5.6cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251120\_120530.png\end{minipage}}
\fbox{\begin{minipage}[c][5.6cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251120\_120621.png\end{minipage}}
\end{center}


\subsection{Persistent Segment Tree}
\label{pst}
Vogliamo che la data structure sia persistent, ovvero abbiamo delle operazioni che fanno l'update della data structure, e certe che fanno le query, adesso però possiamo dare un timestamp con la query e vogliamo lo snapshot della struttura e via. 


Dato $A[0,n-1]$ 
\begin{itemize}
  \item Add(i,v)
  \item RangeSum(i,j,t) dove t è il timestamp
\end{itemize}

Facciamo piu soluzioni stupide:
\begin{itemize}
  \item Facciamo una copia del ST dopo ogni update, pro: range sum in $\Theta (\log n)$ time ma cons: space usage $\Theta(n \cdot t) $ dopo $t$ update, inoltre add operation prende $\Theta(n)$ time (perche si copia tutto il ST).
  \item Exploit: non ha senso copiare visto che non si cambia tutto, quindi abbiamo solamente n $\Theta (\log n)$ nodi dopo ogni update: 
\end{itemize}

\begin{multicols}{2}
\begin{center}
  \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_154518.png\end{minipage}}
\end{center}
\columnbreak

Si fa questa bella add, e vediamo che cambiamo questi nodi, allora per ogni nodo si tiene tutti i valori che hanno preso durante il tempo, quindi non ci teniamo solo un valore ma una lista di valori e di timestamp, in questo caso vediamo che 21 ha solo 21,0 visto che non è stato cambiato.
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_154921.png\end{minipage}}
\end{center}
\columnbreak
Adesso facciamo un'altra add, e vediamo che accanto 21 viene 41,2, visto che godo.
\end{multicols}
Pro: add prende $\Theta (\log n)$ e space $\Theta ( n + t \cdot \log n)$ e range update prende

RangeSum(i,j,t) cerca per il predecessor di $t$ in ogni lista dei Total OVerlapping Node, Time Complexity: $\Theta(\log n * \log t)$ ($\log t$ perche si fa una binary search dentro la lista)

Finalmente soluzione \underline{FIGA}:
Exploitiamo il fatto che tutti i $\log n$ nodi sono da una root-to-leaf path. Aggiungiamo un array. Si replica i nodi che cambiano e basta insomma.

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_164825.png\end{minipage}}
\end{center}
\columnbreak
in questo caso il nodo in posizione 3, ovvero 4 con 14, e dobbiamo cambiare anche il suo genitore, e si fanno proprio delle copie e si mettono al posto di quelli vecchi, ma comunque si utilizza l'array per puntare alla nuova root. 
\end{multicols}

quindi è tutto come se fosse solamente un ST, semplicemente a seconda il timestamp cambia solamente lo starting point. 



\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_165444.png\end{minipage}}
\end{center}
\columnbreak
Se facciamo un'altra add semplicemente ci prendiamo i nodi sempre del timestamp diverso, e come si fa? \underline{il parent deve essere sempre the last one}, quindi è easy. tanto per fare una ricerca si parte dalla root e quella si prende sempre con l'array. 
\end{multicols}

\begin{itemize}
  \item RangeSum prende $\Theta (\log n)$ time
  \item add  prende $\Theta (\log n)$ time
  \item space usage prende $\Theta (n + t \log n)$ dopo t update
\end{itemize}

\clearpage

\section{Mo's Algorithm}
\label{mo}
D'ora in poi si prenderanno un sacco di queryrange (ancora), Se è una sum query con update si puo' risolvere con un FT, mentre per le altre si possono risolvere con ST, ma deve essere possibili suddividere la query in sub query ed è cosi che si usa l'ST. MA NON PER TUTTEEEE

\subsection{Problem meno difficult} 
Dato $A[1,n]$ di colori (valori $\le n$), e un set di Q di q queries (OFFLINE).

\begin{itemize}
  \item 3 o piu (i,j): report \# of distinct color that occur at least 3 times in $A[i,\dots,j]$
\end{itemize}

Target time complexity: $\Theta((n+q) \sqrt n )$ time

Facciamo una \textbf{trivial solution}: $\Theta(n \cdot q)$ time

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_113923.png\end{minipage}}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_114201.png\end{minipage}}
\end{center}
\columnbreak
Si usa un array di counters per contare il numero di occurences 
\end{multicols}

Adesso vorremmo usare la risposta alla prima query per dare una mano alla seconda, abbiamo un array di counters e abbiamo la variabile \texttt{Answer} che ci conta il numero di colori con almeno 3 occurences.

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_115812.png\end{minipage}}
\end{center}
\columnbreak
Abbiamo la seguene query, e sappiamo la sua risposta, se la prossima sarà un range diverso da quello della prima, si toglie semplicemente la parte che non ci interessa e via, ovviamente se non c'è overlap stiga
\end{multicols}

Soluzioe definitiva per questo tipo di trick:

\begin{multicols}{2}

\fbox{\begin{minipage}[c][4.2cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_122425.png\end{minipage}}

\columnbreak

\fbox{\begin{minipage}[c][4.2cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_122816.png\end{minipage}}

\end{multicols}

Notare che abbiamo sempre:  $\Theta(n \cdot q)$ time  però l'ordine delle query serve, quindi che strategia si usa? vogliamo l'ordering per minimizzare il numero di elementi da togliere e da aggiungere, ma ancora non andrebbe a ridurre il running time.

Notare: \underline{esiste un ordering delle queries che permette un time complexity di $\Theta((n+q) \sqrt n )$}.

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_123649.png\end{minipage}}
\end{center}
\columnbreak
Si raggruppa le query dal loro left extreme (\texttt{cur\_i}), in gruppi di size $\sqrt n$. (si fa il sort (i,j) by ($i/\sqrt n$,j))

In ogni gruppo si fa il sort del right extreme (\texttt{cur\_j}), e si vanno a risolvere le queries.
\end{multicols}

Siamo in un gruppo abbiamo cur\_i e curr\_j, consideriamo \texttt{cur\_j}, che alle brutte dentro il gruppo può arrivare fino a n. Quindi per ogni gruppo al massimo facciamo n "move", ovvero dobbiamo fare l'add n volte.

quindi overall $\Theta(n\sqrt n)$ moves (o calls to add).

\begin{multicols}{2}
\begin{center}
  \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_152358.png\end{minipage}}
\end{center}
\columnbreak
Invece quante moves facciamo in base a \texttt{cur\_i}? siamo nella situazione dell'immagine, ovvero si distano al massimo di $\sqrt n$, quindi se nel gruppo ci sono $b_i$ queries, allora si fanno al massimo $\Theta(b_i \cdot \sqrt n)$ moves per gruppo $i$
\end{multicols}

Quinid quante in tutto? $\Theta(\sum_{i=1}^{\sqrt n} b_i \cdot \sqrt n) =\Theta(\sqrt \cdot q)$ 

Quindi in tutto $\Theta(n \cdot \sqrt n + q \cdot \sqrt n) = \Theta((n+q) \sqrt n )$ 


\subsection{A Difficult Problem}
Dato un array A[0,n-1], 

\begin{itemize}
  \item Answer q queries (OFFLINE)
\end{itemize}

Online ovvero fare q queries una dopo l'altra e una risposta dopo l'altra, mentre OFFLINE abbiamo tutte le query in una volta e si deve dare la risposta a tutte le query insieme. 

\begin{itemize}
  \item Query(l,r) = $\sum_{e \in D(l,r)} e \cdot Ke^2$
\end{itemize}

D(l,r) = set of distinct element in $A[l \dots r]$, 

Ke = numero di occurences di $e$ dentro $A[l \dots r]$

quindi per ogni distinct element nel range dobbiamo computare quel lavoro, Ke è il numero di occurence dei distinct elemetn

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251118\_184037.png\end{minipage}}
\end{center}

Target time complexity: $\Theta((n+q) \sqrt n )$ time

Ora discutiamo della versione statica del problema.

(ORA SAPPIAMO COME FARE LA PARTE SOPRA ERA PRIMA GASSE)

\begin{multicols}{2}
\begin{center}

\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_153625.png\end{minipage}}

\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_153701.png\end{minipage}}

\end{center}
\columnbreak
Si fa come prima, ma semplicemente cambia la contribuzione all'interno di answer:
\end{multicols}

\section{(STATIC) RMQ}
\label{rmq}
Abbiamo fatto prefix sum static, che si risolve con un array, prefix sum dynamic che si risolve con FT, altre range queries che si risolvono con un ST, inoltre abbiamo fatto anche cose piu carine offline con mos algoritmh.

Range Minimum Queries, sono piu difficili di prefix sum, nel caso \textbf{dinamico} si possono risolvere con ST con tempo logaritmico, ma nel caso statico si possono risolvere in maniera lineare. 

Dato $A[0,n-1]$

\begin{multicols}{2}
\begin{itemize}
  \item RMQ(i,j) = argmin($A[i \dots j]$)
\end{itemize}
\columnbreak
\begin{center}
  \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_155819.png\end{minipage}}
\end{center}
\end{multicols}


Target $\Theta(1)$ time e $\Theta(n)$ space (ST fa log n per query)

Prima soluzione brutta: $\Theta(1)$ time e $\Theta(n^2)$ space, si fa una tabella con tutte le possibili risposte e via gasse.

\begin{multicols}{2}

Seconda soluzione brutta: sparse array, $\Theta(1)$ time e $\Theta(n\log n)$ space, si fa l'exploit del fatto che due range che si overlappano hanno la risposta di una query che li comprende entrambi, basta fare il minimo tra i due.

\columnbreak

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_160356.png\end{minipage}}
\end{center}
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_164341.png\end{minipage}}
\end{center}
\columnbreak
Facciamo una tabella piu piccola, si tengono le risposte per $[i,i+2^k]$ per ogni $k$, per la query si fa: 

\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_164722.png\end{minipage}}
\end{center}
\end{multicols}

\clearpage

Soluzione 3: $\Theta(\log n) $ time e $\Theta(n) $ space 

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_165213.png\end{minipage}}
\end{center}
\columnbreak
Creiamo dei blocchi dentro A lunghi $\log n$ e poi si tiene $A'$ dove teniamo l'elemento minimo di ogni blocco, ovviamente $A'$ è grande $\frac{n}{\log n}$ e si usa la soluzione di prima
\end{multicols}

\begin{multicols}{2}
\begin{center}
  \fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_165657.png\end{minipage}}
\end{center}
\columnbreak
questo è il modo per risolvere le query, cosi abbiamo tempo costante per il total overlap, mentre per calcolare il prefix (verde) e il suffix (rosso) della query che non sono direttamente su un blocco di $A'$ si fa semplicemente uno scan e questo costa al massimo $\log n$ e infatti si godeeeeeeeeeee
\end{multicols}

ULTIMA SOLUZIONE: $\Theta(1)$ time e $\Theta(n)$ space 
Solo l'intuizione 

\subsubsection{Cartesian Tree}

2 regole: 

\begin{itemize}
  \item Ogni nodo ha sotto sempre uguale o maggiore,
  \item La posizione dei nodi nell'albero deve rispettare l'ordine originale dell'array.
\end{itemize}

Se ci sono duplicati, allora si prende quelo piu a sinistra.

IDEA HO CAPITO, si prende sempre il minimo e da li si splitta in due, e cosi via si prende sempre il minimo da sinistra, godooooooo

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_171303.png\end{minipage}}
\end{center}
\columnbreak
Si crea l'albero on top di A, ci mettiamo dentro il minimo ovviamente, la root è l'elemento minimo, si splitta l'array in due parti. 

Il valore piu piccolo è 1, per cui è la nostra root ovviamente quello piu a sinistra, allora dopo c'è 2, e sempre uno a destra come figlio, successivamente il piccolo a destra è sempre 1 e cosi via fino infondo. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_173013.png\end{minipage}}
\end{center}
\columnbreak
Quindi in questo caso RMQ(4,8) = 1, perche la risposta alla query è sempre la root di quel sub tree, ovvero LCA(4,8)  lower common ancestor
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_184917.png\end{minipage}}
\end{center}
\columnbreak
Quindi basta supportare LCA per rispondere alla query, ma noi abbiamo dei blocchi piccoli, si usa le balance parantesis, quando si trova un nodo per la prima volta si mette un parantesi aperti, quando si smette di visitarlo, quindi non ci passaremo piu, ne metteremo una chiusa, in tutto sono \texttt{2n bits}
\end{multicols}

\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_192449.png\end{minipage}}
\end{center}
\columnbreak
In questa maniera possiamo ricostruire tutto il tree, GODOOOOO, la prima parentesi è la root, e cosi via si ricostruisce, ma quindi servono \texttt{4n bit} perche dobbiamo anche capire se il figlio è a destra o a sinistra. 
\end{multicols}

recap: come si fa questa cosa? si rappresenta ogni blocco dentro un cartesian tree e si trova il LCA con questi bit strani. 

ROBA TEORICA NON TRIVIAL COME DICE IL PROF:
Calcoliamo il tempo, mettiamo che stavolta si fanno i blocchi di $\frac{1}{8} \log n$ bits quindi il cartesian tree si rappresenta con $4 \cdot \frac{1}{8} \log n = \frac{1}{2} \log n$ bits. Quindi abbiamo $2^{\frac{1}{2} \log n}$ possible tree rappresentation ma questo è  $2^{\frac{1}{2} \log n}= \sqrt n$.

Quindi insomma si fanno tutti i possibili tree (? TODO: chiedere) e abbiamo sempre la risposta in costant time.

\clearpage

\subsection{Colored Range Query Problem}
Dato $A[1,n]$ di colori (integer $\le n$)

\begin{multicols}{2}
\begin{itemize}
    \item Distinct (i,j) ritorna all distinct color in $A[i,j]$ in tempo proporzionale a $k = \# $ di distinct color in $A[i,j]$
\end{itemize}
\columnbreak
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_193623.png\end{minipage}}
\end{center}
\end{multicols}

Prima soluzione: Segment tree con hashset, $\Theta(k \cdot \log n)$ e space $\Theta (n \log n)$ 

Bella soluzione: Space $\Theta(n)$ e query time $\Theta(k)$ quindi ottimaliiii


\begin{multicols}{2}
\begin{center}
\fbox{\begin{minipage}[c][2.8cm]{\linewidth}\centering \tiny \textbf{IMG MANCANTE} \\ Screenshot\_20251119\_195246.png\end{minipage}}
\end{center}
\columnbreak
Abbiamo il nostro array, e per ogni valore: se è la prima occurence si connette al "PUNTO ROSSO" e se invece si trova una occurence si connette alla occurence prima, Poi ci teniamo un array dei pointer semplicemente, cosi sappiamo a chi si chiedeee
Abbiamo il nostro query range che va a 3 a 6, e vediamo che ogni distinct element ha \textbf{esattamente una freccia che crossa la linea blu}, grazie punto rosso. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251129_111855.png}
\end{center}

\columnbreak
Quindi sapendo questa cosa, basta usare l'array P di pointer e cerchiamo in maniera ricorsiva i numeri piu piccoli del min della range query. E ci si ferma quando si trova numeri piu grossi di 3, perche tanto no freca, particamente si fanno RMQ nell'array P e ricorsivamente si crea il cartesian tree dei range, e non si va ricorsivamente giu, ma si va ricorsivamente a destra e a sinistra, e si fa solamente la ricorsione per elementi minori di 3, se ne perde 2 piu o meno per ognuno quindi siamo sempre nell'ordine di k.
\end{multicols}

Bella merda ho scritto ma si capisce dai su.

\subsection{Range Minimum Querys}
Abbiamo un array e si chiede di reportare gli elementi piu piccoli di un certo $k$: 
\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251129_112649.png}
\end{center}
\columnbreak 
Abbiamo l'array e sicuro dobbiamo riportare 1 e 2, si inizia e si chiede il minimo di tutto l'array, allora si fa una ricorsione a sinistra e destra e si continua cosi a chiedere il minimo, e ci si ferma ovviamente quando il minimo è piu grande o uguale a $k$.
\end{multicols}

Quanto costa? si sta costruendo un cartesian tree quindi comuqnue $O(k)$

\section{Dynamic Programming}
\subsection{Fibonacci Numbers}
Riusiamo tutto quello che abbiamo gia fatto godendo nel mentre.

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251129_113221.png}
\end{center}

Si fa schifo questo algoritmo, ci teniamo le risposte in una tabella e si risponde continuamente.

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251129_113341.png}
\end{center}
\columnbreak
\textbf{TOP DOWN APPROAC}: Ci teniamo la tabella M inizializzata a 0. 
\end{multicols}

Possiamo anche avere un bottom down approach cercando di fare un algoritmo piu veloce:

\subsection{Matrix Exponentiation}
Dobbiamo fare $A^n$, si fa divide and conquer, sappiamo che:

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251129_120738.png}
\end{center}

\subsection{Rod Cutting}
Abbiamo una barra di acciaio, di lunghezza $n$ per un taglio di lunghezza $i \in [1,n]$  si prende $P_i$ euros, e vogliamo massimizzare il guadagno, ovvero trovare i cuts che massimizzano la revenue totale. 

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251130_121511.png}
\end{center}

Soluzione: quali sono i sub problems? solamente smaller input, quindi qui è : Optimal way to cut a rod of length K < n. 


\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_091737.png}
\end{center}
\columnbreak
Combine: $R(n) = \max _{1 \le i < n} \{R(n-1) +  P_i\}$ ovvero facciamo il sub problem e andiamo avanti restringendo $i$. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_093113.png}
\end{center}
\columnbreak
Prima si inizializza la tabella dei total revenie, poi per ogni i a n+1 e per ogni l in che va fino ad i, si prende il massimo tra quello che c'è ora e toglie tutti gli i.  $R[i-l] + P[l]$ ovvero tutti i possibili tagli da fare in quel pezzo di $i$.
\end{multicols}

\subsection{facebook: Robber}
\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_093457.png}
\end{center}
\columnbreak
Sei in strada,  e ci sono n case, possiamo rubare la casa e prendere la revenue $r_n$, ma c'è un costraint,  se si ruba la casa $i$ non si può rubare in $i-1$ e $i+1$. 
\end{multicols}

Ci serve un tool: 
\subsubsection{shortest/longest path computation on a DAG}
Si definiscono dei nodi speciali, \textbf{Source} e \textbf{Destination}, si attacca a tutti la source e arrivano tutti alla destination, abbiamo la wheight $w_{i,j}$ (il costo) e quindi vogliamo trovare il path dalla source alla destination con il massimo dei pesi oppure il minimo non importa. 

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_094101.png}
\end{center}

Si usa l'algoritmo di dijikistra, abbiamo un heap e ci si mette U nodi dentro con il loro costo, e si estrae quello con costo minore, e si rilassano tutti gli edges che escono da quello, non ci ho capito una sega. costo numero di nodi + numero di archi per log n visto che si parla di heap. 

Ma c'è un'altro modo, senza heap, perche se si processano i nodi fino ad arrivare al nodo $i$ in ordine, gli altri non si cagano, questo perche in un DAG tutti gli archi che arrivano ad $i$ si sono gia processati, mentre quelli a destra di $i$ ancora non si sono cagati, allora cosa si fa? 

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_095706.png}
\end{center}
\columnbreak
Si tiene il costo dello shortest path per arrivare a quel nodo $c_i$, inizialmente sono tutti $\infty$, e step by step si computa lo shortest past da sinistra a destra. Per ogni vertex che si processa, si rilassano tutti i vertici. 
\end{multicols}


\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_095924.png}
\end{center}
\columnbreak
Ovvero se $i,j$ è un edge, allora il costo per andare a $j$, diventa il minimo tra il costo di $c_j$ e $c_i+w_{i,j}$, e da sinistra a destra si fa questo calcolo e visto che le wheight sono sempre positive, gasse. Traduzione: "Al nodo j conviene tenersi il costo che aveva prima, o arrivarci passando da me (i)?"
\end{multicols}

\subsubsection{Road cutting: ma con il DAG}
Si fa il dag con un nodo per ogni cut, e tutti i nodi sono connessi a tutti quelli dopo, e come revenue il guadagno da 1 a $i$ è $P_{i-1}$

Di nuovo numero di edge piu numero di vertex, quindi sempre quadratico in questo coso brutto.

Esempio da gemini: 


Il problema consiste nel massimizzare il profitto tagliando un'asta di lunghezza $N=4$. Modelliamo il problema come la ricerca del cammino a costo massimo (Longest Path) su un DAG, dove i nodi rappresentano i punti di taglio ($0 \to 4$) e gli archi rappresentano i pezzi venduti.

\paragraph{Dati di Input}
I prezzi per i tagli sono:
\begin{itemize}
    \item Taglio da 1m: $1$€
    \item Taglio da 2m: $5$€ (Pezzo pregiato)
    \item Taglio da 3m: $8$€
    \item Taglio da 4m: $9$€
\end{itemize}

\paragraph{Logica dell'Algoritmo}
Poiché il grafo è un DAG, processiamo i nodi linearmente da sinistra a destra (da 0 a 4). Utilizziamo la formula di rilassamento per massimizzare il profitto:
\[ DP[j] = \max(DP[j], \quad DP[i] + P_{(j-i)}) \]
In pratica, per ogni nodo, controlliamo se conviene arrivare lì estendendo un percorso precedente.

\bigskip
\noindent \textbf{Esecuzione Step-by-Step}

\textbf{1. Inizializzazione al Nodo 0 (Source)} \\
L'array dei profitti parte vuoto (o a $-\infty$), eccetto la sorgente.
Dal nodo 0 lanciamo gli archi verso tutti i nodi futuri:
\begin{itemize}
    \item Verso 1: $0 + 1€ = 1$
    \item Verso 2: $0 + 5€ = 5$
    \item Verso 3: $0 + 8€ = 8$
    \item Verso 4: $0 + 9€ = 9$
\end{itemize}
\textit{Stato Array:} $[0, \mathbf{1}, \mathbf{5}, \mathbf{8}, \mathbf{9}]$

\medskip

\textbf{2. Processiamo il Nodo 1 (Profitto attuale: 1)} \\
Proviamo ad estendere il percorso partendo dal nodo 1:
\begin{itemize}
    \item Verso 2: $1 + 1€ = 2$. (Minore di 5, ignoro)
    \item Verso 3: $1 + 5€ = 6$. (Minore di 8, ignoro)
    \item Verso 4: $1 + 8€ = 9$. (Uguale a 9, ignoro)
\end{itemize}
\textit{Nessun miglioramento.}

\medskip

\textbf{3. Processiamo il Nodo 2 (Profitto attuale: 5)} \\
Qui avviene il rilassamento cruciale (il sorpasso):
\begin{itemize}
    \item Verso 3: $5 + 1€ = 6$. (Minore di 8, ignoro)
    \item Verso 4: $5 + 5€ = 10$. (Maggiore di 9! \textbf{Aggiorno})
\end{itemize}
\textit{Stato Array:} $[0, 1, 5, 8, \mathbf{10}]$

\bigskip
\noindent \textbf{Conclusione} \\
Arrivati alla fine, il profitto massimo accumulato al nodo 4 è \textbf{10€}. \\
Il percorso vincente sul DAG è: $0 \xrightarrow{+5} 2 \xrightarrow{+5} 4$, che corrisponde a due tagli da 2 metri ciascuno.

\subsubsection{Torniamo a faceboooooook}
Come si fa con il dag? Se abbiamo un arco che arriva vuol dire che si deve rubare, ma non si puo andare nella casa dopo. sempre $\Theta(n^2)$ time 

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_102951.png}
\end{center}

Consideriamo anche che possiamo togliere degli edge, questo perche non ha senso andare da i a $i+4$, perche possiamo prima andare a $i+2$ e poi si va a $i+4$ in questra maniera abbiamo solamente 2 archi che escono da ogni nodo e quindi $\Theta(n)$

\subsection{Snake and ladders} 
Abbiamo una matrice, si inizia dalla cella 1 e dobbiamo raggiungere 100, ci si muove con un dado, e ci sono snake che ti riportano in dietro e ladder che ti portano avanti, trovare il minimo numero di tirate di dado per arrivare in fondo.

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_103607.png}
\end{center}

Si trasforma ogni cella in un nodo, e per ogni nodo abbiamo 6 archi (le facce del dado), e se si va su un ladder si va al suo nodo e via, e si computa lo shortest path, e via.

Nunning Time: $\Theta(n)$

\subsection{Minimum Cost Path}
A è una n * m matrice con degli integer, l'obbiettivo è computare il path di costo miimo dal top-left angolo al bottom right muovendoci solamente in basso e a destra.

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_104329.png}
\end{center}

\subsection{Longest Common Subsequence LCS}
Dato $S_1$ ($|S_1|=n$) e $S_2$ ($|S_2|=m$) trovare LCS($S_1,S_2$),

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_105704.png}
\end{center}

Vogliamo $\Theta (n \cdot m)$ time.

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_110039.png}
\end{center}

\includegraphics[scale=0.2]{Screenshot_20251201_110417.png}
\begin{center}
\end{center}

\columnbreak

Dobbiamo trovare il sub problem ovvero prendere il i prefissi delle due stringhe. E dobbiamo trovare come combinarli, ovvero aggiungere due simboli alle stringhe gia processati, ovvero c1 == c2, se sono uguali gasse, se no stica. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_110619.png}
\end{center}
\columnbreak
se sono lunghe 0 allora 0, se sonouguali allora gasse, e per gli altri casi uguali. 
\end{multicols}

Ma questo approccio è top down, dobbiamo fare la ricorsione. mentre vorremmo buildare la tabella dall'inizio e pienare la tabella per riga e non per colonna.
\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_110959.png}
\end{center}
\columnbreak
Si fa una tabella 2D, inizialmente sappiamo tutte le risposte per la prima riga e colonna, quindi 0, e si usa la recurrence per iniziare a fare la tabella. 
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_111307.png}
\end{center}
\columnbreak
Notare che si usano le celle in alto, a sinistra  e in alto a sinistra per fare calcolare la cella corrente. 
\end{multicols}

\subsection{0/1 knapsack problem}
0 si prende l'item e 1 no, e si deve prendere piu item possibili per massimizzare il peso dello zaino. Abbiamo $n$ items e abbiamo $C$ capacity, ogni item $i$ ha un valore $v_i$ e una weight $w_i$, prendere un subset di item che massimizza il valore rimanendo nella $C$ capacity.

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_111711.png}
\end{center}

Vogliamo $\Theta (n \cdot C)$ time.

Cerchiamo il problema per una capacity piu piccola e meno item (ovvero si fa un ordering e si prende il prefix via via), e il combine è il seuguente:

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_112942.png}
\end{center}
\columnbreak
Abbiamo $i$ item mentre prima ne avevamo i-1 item, e si vuole prendere l'item $i$ ? No, ovvero si prende la soluzione prima, ma se si prende allora si prende la soluzione di prima  + il suo valore, ma dobbiamo fargli spazio, quindi $J-w_i$. 
\end{multicols}

recurrence? ovvero come si fa il base case ? o il caso normale? 
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_113059.png}
\end{center}

Cosi è facilissimo, si fa row wise, quindi bottom up, seguendo l'algoritmo gasse, 
\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_113425.png}
\end{center}
\columnbreak

per ogni cella si prende sempre il massimo valore possibile, e in caso si controlla se togliere l'ultimo item ha senso. 
\end{multicols}

\subsection{Fractional knapsack}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_114549.png}
\end{center}

Si fa in $\Theta(n \log n)$ time, con un algoritmo greedy, per ogni item si fa il ratio$_i = \frac{v_i}{w_i}$ value per unit of weight, si sortano gli item b decreasing ratio, cosi si massimizza il valore  e si selezionano gli item fino a che non si finisce la capacity. 

\subsection{Puzzle exercise}
Abbiamo 2 pairs of coins, selezionare $k$ coins per massimizzare il total value, ma si puè selezionare il secondo coin solo se anche il primo è stato selezionato. 

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_120112.png}
\end{center}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_120353.png}
\end{center}
\columnbreak
Con k= 1 si prende 10 perche possiamo solo sezionare questo, 12 non si puo prendere perche si deve prendere 1 prima. 
\end{multicols}

Comunque con k=3 non si estende le soluzioni gia fatte, perche si prende 10 poi 1 e poi 12, quindi come si fa????

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_120545.png}
\end{center}
\columnbreak
Prima soluzione $\Theta(n^2)$, dag strategy e via , fake source e destination, e si connettono, ma dobbiamo fare lo shortest path di length k.
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_121317.png}
\end{center}
\columnbreak
Seconda soluzione, fa $\Theta(n k )$ time , si fa un approach come il knapsack fractional, un coin ha weitght 1, un coin e il suo pair ha weight 2, ma non ho capito.
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_121606.png}
\end{center}
\columnbreak
terza soluzione: $\Theta(n \log n)$ si fa un greedy approach, e si usano gli item della seconda soluzione, si fa il ratio e si sortano ma dobbiamo stare attenti di non prendere il coin al primo livello. 
\end{multicols}

\subsection{Longest Increasing Subsequence (LIS)}
Dato una sequenza S di n elementi, trovare LIS di S.  Ovvero una sequenza di elementi che è increasing, ma vogliamo quella piu lunga 

\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_121821.png}
\end{center}

Prima soluzione quadratica: si prende il sub problem, ovvero si prende solo il prefisso della sequenza, ma qui non serve perche dobbiamo ricordarci i numeri che compongono la LIS, quindi come si fa? 

Si forza che LIS(i) finisce con S[i] dove è l'ultimo elemento della LIS, cosi possiamo fare: 
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_122510.png}
\end{center}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_122805.png}
\end{center}
\columnbreak
La cosa brutta è che dobbiamo fare il check di tutte le LIS trovate finora, quindi gasse, quadratico.
\end{multicols}

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_123159.png}
\end{center}
\columnbreak
Soluzione 2: sempre quadratica, si trasforma tutto in un nodo, si fa la fake destination e source, si connette ad ogni nodo i suoi nodi che possono estenderlo nella LIS, e si fa il longhest path. 
\end{multicols}

\clearpage

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_124512.png}
\end{center}
\columnbreak
3 soluzione $\Theta(n \log n)$, diciamo che una posizoone $i$ domina una posizione $j$ se $S[i] < S[j]$ e $LIS[i] \ge LIS[j]$.

Se vale questo j è inutile per i, in questo caso per 16 j è inutile ed è melgio comuqnue prendere $i$ perche 13 può prendere 
\end{multicols}

Tutti i valori inoltre nei LIS sono rappresentati. C'è solamente una posiziooen dominante per ogni valore possibile di LIS.

\begin{multicols}{2}
\begin{center}
\includegraphics[scale=0.2]{Screenshot_20251201_124512.png}
\end{center}
\columnbreak
Si tiene un valore di Dominating Position, come si piena questa tabella? si cerca un valore piu piccolo di quello corrente, abbiamo 10, estende qualcosa? no quindi 1, é 10 una posizione dominante? si va nella tabella e si guarda se c'è 

Ora 22 si può estendere, e quindi anche 22 può dominare,  MA IL PROF HA INTERROTTO LA LEZIOEN 
\end{multicols}

\section{Greedy}
\subsection{Activity Selection Problem}
n Attivita rappresentate come intervalli, select the largest number of non-overlapping activities 

Disegno prof intervalli 

Come si affronta, si cerca l'euristica greedy per fare la scelta giusta, ma deve darci al soluzione optimal, e per fare questa cosa basta trovare un proof oppure un controesempio (E SI TROVA SEMPRE UN CONTROESEMPIO), in questo caso:

\# 1 strategy: si selezione in base a chi ha lo starting time piu piccolo. Si selezione una attività iniziale, si levano le overlap e si prende quella che inizia prima, va bene? Ovviamente con un esempio stupido non funziona questo esempio. 

\# 2 strategy: Select Smallest first, anche questa fa cagare 

\# 3 strategy: Selezionare prima le attività che hanno meno overlaps, manco questa è optimal.

\# 4 strategy: Ending Time, si prende quella che finisce prima e si prende, poi tra quelle che finiscono prima che non overlappano si prendono, gasse funziona $\Theta (n\log n)$ time.

Adesso dobbiamo provarlo che è quello optimal:

\paragraph{Lemma}: "there exists at least an optimal solution which includes the first ending activity f"
\paragraph{Proof}: dobbiamo provare questo lemma, immaginiamo di aver una optimal solution, chiamata O*

\begin{multicols}{2}

FOTO PROOOOF

\columnbreak

Vogliamo modificare una optimal solution facendo vedere che se la modifichiamo con la nostra strategia allora abbiamo lo stesso risultato.

Diciamo che la sua prima attività g, non è la prima che finisce, ma ce ne è una f che finisce prima, e se comunque prendiamo questa allora $O_p *$ rimane comunque optimal.

\end{multicols}

\subsection{Job Sequencing}
Per ogni job , id, deadline e profit, si deve fare il job prima della deadline, e ogni job consuma uno slot di tempo.

FOTO PROF 

Quale strategia? si sortano per valore, e poi si processano dal piu alto di valore al piu basso, dove si mette a? si mette nella sua deadline incredibile, 
Si buttano gli empty slot in un BST, si prendono in nodi i decreasing order, e ci chiediamo la sua deadline è presa? no? allora ci si mette, se no? si cerca un predecessor della deadline nel BST e cosi via.

\subsection{Magic Numbers}
Un numero magico è formato concatenando i numeri 1,14,144. Per esempio 14141 è un numero magico, mentre 1444 non è un numero magico. Determinare se un numero è un magic number. 

Proprieta figa: nessuna stringa è il suffix dell'altra, 1 non è il suffisso di 14, e nemmeno 14 lo è per 144, per questo gasse. E la strategia greedy? si prende sempre la stringa piu grande.

\subsection{Lemple-Zir} 
E' un algoritmo greedy, si traversa da sinistra a destra nel testo, e voglio trovare la stringa piu grande possibile che si ripete nel "passato", cosi da zippare meglio la stringa (è un algo di compressione).

Che si fa? scrive dei pair dove puntare e quanto sono lunghi. 

In questa maniera si fa il parsing da sinistra a destra e si da gassssssssssssssssssssssssssss

\subsection{Lexicographically Maximum Subsequence}
Data una sequenza tipo \texttt{ababba} vorremmo selezionare una sequenza tipo \texttt{bab}, ma non è quella piu grande, perche vogliamo quella lessicograficamente piu grande infatti \texttt{aabba} $<$ \texttt{aabc}.

\begin{center}
\texttt{abbcbccacbbcbaaba}
\end{center}

Si fa la scan da destra a sinistra e ci teniamo solo le stringhe che sono piu grandi godo, nell'esempio, si prende a si prende b poi b perche è uguale a noi,  poi c e tutti gli c fino in fondo e si gode, tanto vince sempre la piu grande partendo da sinistra quindi gasse.

\subsection{Pareto Optimal Selection}
Vogliamo selezionare la parte optimal frontier, ovvero punti che prendono dominano gli altri, ovvero (x,y) domina $(x_i,y_i)$ se $x > x_1$ e $y>y_1$, 

foto proofofoffffff

\subsection{Woodcutter}
ULTIMA LEZIONE :(((((((((((((((((((((((((((((

una foresta di alberi, n trees, ogni albero ha la sua altezza, vogliamo massimizzare il numero di alberi che possiamo tagliare, quando tagliamo l'albero possiamo decidere se farlo cascare a destra o sinistra, ma non possiamo scegliere di talgiare un tree che casca su un'altro albero. Ovviamente vogliamo tagliare piu alberi possibile, in ogni caso anche se l'albero è stato tagliato, non possiamo tagliarlo. 

FOTO PROOOOF 

Semplicemente prima si controlla se l'albero si può far cascare a sinistra, se no si controlla a destra, e se può cascare ma influenza comunque stica, godo tanto è sempre un albero in meno.

\subsection{queue}
coda, ogni persona ha un'altezza e il numero di persone davanti a lei nella coda che sono piu alte di lei. Possiamo ricostruire la coda? in certi casi è possibile 

FOTO PROF

Ovviamente si lavora al contrario, quindi da destra a sinistra. Si prende $\Theta(n^2)$ time, si sortano le altezze in decreasing order e per ognuno partendo da sinistra a destra si mette nel suo posto a patto che non distrugga la condizione di un'altro numero prima.  

c'è un algoritmo piu stupido, creare un array e fare l'insert dentro all'array, ma costa quadratico ugualmente, FOTO PROF CODICE. tanto basta sempre metterlo in quella posizione visto che abbiamo sempre la 

TOODOOOOOO: CERCARE UNA SOLUZIONE A QUESTO PROBLEMA PIU FIGA DELLA SKIP LIST

Soluzione con la skip list la sappiamo gia grazie Ferragina. log n di predecessor query, e n di space, godo, e per inserire un elemento li dentro????? gasse si butta il numero dove deve stare e si inserisce e via, si tira il random e si sceglie se farlo scendere e via. 

\subsection{Boxes}
GREDY + DYNAMIC GODO: n boxes, ogni box i  ha $w_i$ pesantezza e $d_i$ surability ovvero la quantità di peso che si può mettere nel box $i$. 

FOTO PROF

Build the highest tower with some boxes. 

Assumento che sappiamo un optimal ordering dei boxes, 

hint: per i primi i boxes dp[i][k] = minimum weight of a tower of height K with the first i boxes.  FOTO PROF con boxes e definizione di dp[i][k]

Per tutti i primi $i$ boxes, voglio la minimum wight di tutte le tower di altezza k (quindi da 1 a k)

(FOTO PROF FORMULA MIN) Quindi dp[i][k] sapendo tutte le soluzioni di dp[i-1][k-1], allora si prende  il minimo tra la torre alta quanto noi ma deigli elementi di prima, oppure si prende la torre di wight minima alta meno di noi quindi dp[i-1][k-1] + noi, quindi $w_i$, ma solo se la noi possiamo sorreggere la torre. Ovviamente $\Theta(n^2)$ time. 

Quindi \textbf{subproblem}: come si seleziona l'ordering migliore?  tra A e B, chi si mette prima o dopo? Se A sta sotto B, allora la durabilità di A diventa $d_A = d_A - w_B$ e invece al contrario $d_B = d_B - w_A$, allora che si fa? si decide solamente in base a:

$$ 
d_A - w_B \le d_B - w_A \Longrightarrow d_A + w_A \le d_B + w_B
$$






















































































































































































































































































































































































































































































































































































































































































































































































































































































































